/*##################################_Pier_Luigi_Manfrini_#############################
 *
 *	This program generates N child processes, each able to generate M times
 *	a stream of characters (of random lenght) to be written into a single
 *      file shared between all processes.
 *
 *	Usage:
 *		<./solution11> <N> <file_name> <M>
 *
 *	Note:
 *		-Is possible to change the value of the two DEFINE provided:
 *			> if DEBUG 1 (1 is default) the output strings are appended 
 *			with some debug info printed in a visible color
 *				(use cat/more/less <file_name> to see colors).
 *			> STR_LEN_RANGE is usefull to change max length
 *				of the strings generated by all children.
 *		-If already existing <file_name> is overwritten.
 *		-This program is good in showing one flaw of rand() used in a multi-
 *		 process scenario such this one: since the initialization is "linked"
 *		 to the same time reference for all processes, and since the randomness
 *		 is based on time (in particular on a second basis timescale), all 
 *		 the i-th calls to rand() within each pocess will happen within the same 
 *		 second. As a result the i-th iterations of all children will withness 
 *		 the same random stream being chosen.
 *
 *	Compile:
 *		gcc solution11.c -o solution11 -Wall -Werror -fsanitize=leak
 *
 * ###################################################################################
 */

#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#define STR_LEN_RANGE 50 // don't set this greater than 4096
#define DEBUG 1

void rand_char_generator(char *, size_t);
void write_char_streams(int, int);

int main(int argc, char **argv) {
  if (argc != 4) {
    dprintf(2, "Wrong Usage: <./a.out> <N> (greater than zero) <file_name> <M> "
               "(greater than zero)\nexiting...\n");
    exit(EXIT_FAILURE);
  }
  srand((unsigned int)time(NULL));
  int N, M, out;
  N = atoi(argv[1]);
  M = atoi(argv[3]);
  pid_t *pid =(pid_t*)malloc(N*sizeof(pid_t));
  if (N <= 0 || M <= 0) {
    dprintf(2, "Both N (# of children) and M (#of streams generated by each "
               "child) must be positive integers\nexiting...\n");
    exit(EXIT_FAILURE);
  }

  /* Open output file fd */
  if ((out = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)) ==
      -1)
    perror("");

  /* Create N children */
  for (int i = 0; i < N; i++) {
    switch (pid[i] = fork()) {
    case -1:
      perror("");
      exit(EXIT_FAILURE);
      break;
    case 0: // Child
      write_char_streams(out, M);
      close(out);

      exit(EXIT_SUCCESS);
      break;
    default: // Father
      break;
    }
  } // end for
  int *status = (int *)malloc(N * sizeof(int));
  for (int i = 0; i < N; i++) {
    if (waitpid(pid[i], &status[i], 0) == -1)
      perror("");
    if (status[i]){
     free(pid);
     free(status);
	    return -1;
    }
  }
  free(pid);
  free(status);
  return 0;
}

void write_char_streams(int fd, int cycles) {
  for (int i = 0; i < cycles; i++) {
    char string[STR_LEN_RANGE + 100];
    /* Random Length character stream is generated */
    size_t length = (size_t)(rand() % (size_t)STR_LEN_RANGE + 1);
    rand_char_generator(string, length);
    if (DEBUG) {
      char append_dbg[100];
      sprintf(append_dbg,
              "\n\033[1;35m^---->%d iteration by CHILD[%d]\033[0m\n", i + 1,
              getpid());
      strcat(string, append_dbg);
    }
    if (write(fd, string, strlen(string)) != strlen(string))
      perror("");
  }
}

void rand_char_generator(char *stream, size_t length) {
  for (size_t _t = 0; _t < length - 1; _t++) {
    /* readable characters between 33 and 126 in ascii table
     * ( 126 - 33 = 93 )
     * */
    stream[_t] = (char)(33 + (int)(rand() % 94));
  }
  stream[length - 1] = '\0';
}
